<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-2022-jp">
<title>The supervise program</title>
</head>
<body>
<a href="http://cr.yp.to/djb.html">D. J. Bernstein</a>
<br><a href="http://cr.yp.to/unix.html">UNIX</a>
<br><a href="top.html">daemontools</a>
<h1><a href="http://cr.yp.to/daemontools/supervise.html">supervise プログラム</a></h1>
<tt>supervise</tt> はサービスを開始させ、監視します。

<h2>使い方</h2>
<pre>
     supervise <i>service</i>
</pre>
<p>
<tt>supervise</tt> はディレクトリ <tt><i>service</i></tt> に移動し、<tt>./run</tt> を起動させます。
<tt>./run</tt> が終了したら、<tt>./run</tt> を再起動させます。
<tt>./run</tt> がすぐに終了したときに起動・終了の繰り返しを防ぐために <tt>./run</tt> を起動させる前に1秒間待ちます。

<p>
ファイル <tt><i>service</i>/down</tt> が存在すれば、<tt>supervise</tt> はすぐに
は <tt>./run</tt> を起動させません。
<a href="svc.html">svc</a> を使って <tt>./run</tt> を起動させ、<tt>supervise</tt> へ別なコマンドを与えることができます。

<p>
<tt>supervise</tt> はディレクトリ <tt><i>service</i>/supervise</tt> でバイナリ形式で状態の情報を保持します。そのディレクトリは <tt>supervise</tt> が書き込み可能でなければなりません。
状態の情報は <a href="svstat.html">svstat</a> を使って読むことができます。

<p>
<tt>supervise</tt> は起動後にすぐに終了することがあります。<tt><i>service</i></tt> に必要なファイルが見つからない場合、あるいは 別の <tt>supervise</tt> が <tt><i>service</i></tt> ですでに動いている場合です。
<tt>supervise</tt> は一度でもうまく動いたら、kill されるあるいは特に終了の指示が出されるということが無い限り終了しません。
<a href="svok.html">svok</a> を使って、<tt>supervise</tt> がうまく動いているか調べられます。<a href="svscan.html">svscan</a> を使って <tt>supervise</tt> プロセスの集まりを安全に開始できます。

<p>
バージョン 0.70 で加わったこと:
<tt>supervise</tt> は <tt>./run</tt> を起動させた後に1秒間待ちます。

<h2><tt>./run</tt> の書き方</h2>
普通は <tt>./run</tt> はシェルスクリプトです。例:
<pre>
     #!/bin/sh
     exec clockspeed
</pre>
ここの <tt>exec</tt> は <tt>sh</tt> に対し、<tt>clockspeed</tt> で自身を置き換えることを指示しています。これにより、<tt>svc</tt> を使って、<tt>clockspeed</tt> に直接シグナルを送ることができるようにしています。

<p>
サービスをバックグラウンドで走らせては「いけない」ことに注意してください。
<pre>
     #!/bin/sh
     # will be repeatedly restarted by supervise
     exec clockspeed &amp;
</pre>
<a href="fghack.html">fghack</a> を使って、自身をバックグランドにおくプログラムを <tt>supervise</tt> に監視させる（制御はしない）ことができます。
<pre>
     #!/bin/sh
     exec fghack inetd
</pre>

<p>
root 権限があれば、
<a href="setuidgid.html">setuidgid</a>を使って、別アカウントのもとでサービスを起動させることができます。
<pre>
     #!/bin/sh
     exec \
     setuidgid qmaill \
     multilog t ./main '-*' '+* status: *' =status
</pre>

<p>
シェルのパイプラインを使うのは一般にはいいことでありません。
<pre>
     #!/bin/sh
     generate-crucial-data | save-crucial-data
</pre>
<tt>save-crucial-data</tt> が起動に失敗すると、
<tt>generate-crucial-data</tt>によりすでにパイプに出されたデータは
捨てられてしまうでしょう。
<tt>svscan</tt>を使えば、以下のように<tt>supervise</tt>下のプロセス群の
パイプラインを安全に開始できます。
<tt>./run</tt> には
<pre>
     #!/bin/sh
     exec generate-crucial-data
</pre>
そして、<tt>./log/run</tt>には
<pre>
     #!/bin/sh
     exec save-crucial-data
</pre>
とします。

<h2><tt>./run</tt> の書き換え方</h2>
<tt>./run</tt> が突然死んだら、すぐに <tt>supervise</tt> は <tt>./run</tt> を再起動させます。そのため、サービスの起動中に <tt>./run</tt> を直接編集することは安全ではありません。
ここでは三つの解決法を示します。
<ul>
<li><tt>./run.new</tt> を編集し、<tt>./run.new</tt> を (分割不能動作として) <tt>./run</tt> に名前を変更します。
それから、<tt>svc -t</tt> を使って、サービスに TERM シグナルを送ります。
サービスの終了後に <tt>supervise</tt> は新しい <tt>./run</tt> を起動させるでしょう。
<li><tt>svc -d</tt> を使って、サービスに TERM シグナルを送り、<tt>supervise</tt> にサービスを再開しないように指示します。
<tt>./run</tt> を編集します。
<tt>svc -u</tt> を使って、 <tt>supervise</tt> にサービスを再開するように指示します。
<li><tt>svc -o</tt> を使って、<tt>supervise</tt> にサービスを再開しないように指示します。
<tt>./run</tt> を編集します。
<tt>svc -tu</tt> を使って、サービスに TERM シグナル を送り、<tt>supervise</tt> にサービスを再開するように指示します。
</ul>
サービスによっては(<tt>fghack</tt>を使うものをすべて含む)
<tt>supervise</tt>からのシグナルでは制御できずに
他の方法で止めなければならないものもあるということに注意してください。

<p>
<tt>./run</tt>で処理するために
<tt>supervise</tt>にパイプで渡されるデータもあります。
多くのプログラムは TERM シグナルを受け取ると入力済の未処理データを
処理しないで捨ててしまうことに注意してください。
しかし、
<a href="multilog.html">multilog</a> プログラムは
読み込んだ全データを終了前に処理するように念いりに設計されています。

<hr>
訳：滝澤 隆史<br>
（Version 0.61 における前野 年紀 氏による訳をベース）<br>
<!-- hhmts start -->
Last modified: Sun Apr 16 20:42:26 2000
<!-- hhmts end -->
</body>
</html>
