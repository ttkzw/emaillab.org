diff -uNr mutt-1.5.14.orig/init.h mutt-1.5.14/init.h
--- mutt-1.5.14.orig/init.h	2006-11-21 02:49:08.000000000 +0900
+++ mutt-1.5.14/init.h	2007-02-26 00:11:28.000000000 +0900
@@ -801,6 +801,13 @@
   ** addresses.  This overrides the compile time definition obtained from
   ** /etc/resolv.conf.
   */
+  { "ignore_linear_white_space",    DT_BOOL, R_NONE, OPTIGNORELWS, 0 },
+  /*
+  ** .pp
+  ** This option replaces linear-white-space between encoded-word
+  ** and *text to a single space to prevent the display of MIME-encoded
+  ** ``Subject'' field from being devided into multiple lines.
+  */
   { "ignore_list_reply_to", DT_BOOL, R_NONE, OPTIGNORELISTREPLYTO, 0 },
   /*
   ** .pp
diff -uNr mutt-1.5.14.orig/mutt.h mutt-1.5.14/mutt.h
--- mutt-1.5.14.orig/mutt.h	2007-01-31 04:49:02.000000000 +0900
+++ mutt-1.5.14/mutt.h	2007-02-26 00:11:28.000000000 +0900
@@ -370,6 +370,7 @@
   OPTHIDETHREADSUBJECT,
   OPTHIDETOPLIMITED,
   OPTHIDETOPMISSING,
+  OPTIGNORELWS,
   OPTIGNORELISTREPLYTO,
 #ifdef USE_IMAP
   OPTIMAPCHECKSUBSCRIBED,
diff -uNr mutt-1.5.14.orig/rfc2047.c mutt-1.5.14/rfc2047.c
--- mutt-1.5.14.orig/rfc2047.c	2006-07-18 10:19:28.000000000 +0900
+++ mutt-1.5.14/rfc2047.c	2007-02-26 00:11:28.000000000 +0900
@@ -711,13 +711,54 @@
   return 0;
 }
 
+/* return length of linear-white-space */
+static size_t lwslen (const char *s, size_t n)
+{
+  const char *p = s;
+  size_t len = n;
+
+  if (n <= 0)
+    return 0;
+
+  for (; p < s + n; p++)
+    if (!strchr (" \t\r\n", *p))
+    {
+      len = (size_t)(p - s);
+      break;
+    }
+  if (strchr ("\r\n", *(p-1))) /* LWS doesn't end with CRLF */
+    len = (size_t)0;
+  return len;
+}
+
+/* return length of linear-white-space : reverse */
+static size_t lwsrlen (const char *s, size_t n)
+{
+  const char *p = s + n - 1;
+  size_t len = n;
+
+  if (n <= 0)
+    return 0;
+
+  if (strchr ("\r\n", *p)) /* LWS doesn't end with CRLF */
+    return (size_t)0;
+
+  for (; p >= s; p--)
+    if (!strchr (" \t\r\n", *p))
+    {
+      len = (size_t)(s + n - 1 - p);
+      break;
+    }
+  return len;
+}
+
 /* try to decode anything that looks like a valid RFC2047 encoded
  * header field, ignoring RFC822 parsing rules
  */
 void rfc2047_decode (char **pd)
 {
   const char *p, *q;
-  size_t n;
+  size_t m, n;
   int found_encoded = 0;
   char *d0, *d;
   const char *s = *pd;
@@ -734,6 +775,16 @@
     if (!(p = find_encoded_word (s, &q)))
     {
       /* no encoded words */
+      if (option (OPTIGNORELWS))
+      {
+        n = mutt_strlen (s);
+        if (found_encoded && (m = lwslen (s, n)) != 0)
+        {
+          if (m != n)
+            *d = ' ', d++, dlen--;
+          s += m;
+        }
+      }
       strncpy (d, s, dlen);
       d += dlen;
       break;
@@ -742,8 +793,29 @@
     if (p != s)
     {
       n = (size_t) (p - s);
-      /* ignore spaces between encoded words */
-      if (!found_encoded || strspn (s, " \t\r\n") != n)
+      /* ignore spaces between encoded word
+       * and linear-white-space between encoded word and *text */
+      if (option (OPTIGNORELWS))
+      {
+        if (found_encoded && (m = lwslen (s, n)) != 0)
+        {
+          if (m != n)
+            *d = ' ', d++, dlen--;
+          n -= m, s += m;
+        }
+
+        if ((m = n - lwsrlen (s, n)) != 0)
+        {
+          if (m > dlen)
+            m = dlen;
+          memcpy (d, s, m);
+          d += m;
+          dlen -= m;
+          if (m != n)
+            *d = ' ', d++, dlen--;
+        }
+      }
+      else if (!found_encoded || strspn (s, " \t\r\n") != n)
       {
 	if (n > dlen)
 	  n = dlen;
diff -uNr mutt-1.5.14.orig/PATCHES mutt-1.5.14/PATCHES
--- mutt-1.5.14.orig/PATCHES	2006-10-30 11:30:55.000000000 +0900
+++ mutt-1.5.14/PATCHES	2007-02-26 00:11:41.000000000 +0900
@@ -0,0 +1 @@
+patch-1.5.14.tt.linear_white_space.1
